go.property("hp", 100)
go.property("max_HP", 100)
go.property("lvl", 1)
go.property("speed", 0)
go.property("damage", 0)
go.property("fire_speed", 1)

local max_speed = 100
local lvl_progress = 1
local max_lvl_progress = 100
local rotation_hero = vmath.quat()
local game_paused = false

local GET_NEW_CHARACT = hash("get_new_charact")
local LVL_UPDATE = hash("lvl_update")
local SHOOT = hash("shoot")
local GET_DAMAGE = hash("get_damage")
local CONTACT_POINT_RESPONSE = hash("contact_point_response")
local TOUCH = hash("touch_mouse")
local ENEMY = hash("enemy")
local EXP = hash("exp")
local SLIDER = hash("slider")
local REBEL = hash("rebel")

function init(self)
	msg.post(".", "acquire_input_focus")
	msg.post("camera", "acquire_camera_focus")
	msg.post("/hero/camera#gamepad", "register")
	
	timer.delay(self.fire_speed, false, function() msg.post(".", "shoot") end)
	
	self.move = 0
	self.damage = go.get("/hero/bullet_go#bullet", "damage")
end

local function take_damage(self, damage)
	if (self.hp - damage) > 0 then
		self.hp = self.hp - damage
	elseif self.hp - damage <= 0 then
		self.hp = 0
		
		msg.post("main:/GUI#game_over", "hero_died")
		msg.post("/statistics#statistics", "get_info_from_hero")
	end

	--send new life to GUI
	msg.post("main:/GUI#helth", "life_update", { life = self.hp })
end

function update(self, dt)
	local pos = go.get_position()
	
	-- need for pause
	if dt == 0 then 
		game_paused = true
	else game_paused = false end
	
	if not game_paused then
		--rotate with camera
		if self.touch ~= nil and self.touch ~= "touch" then --if mouse
			local to = go.get_position() - go.get_position("camera")
			local from = vmath.vector3(self.touch.x, self.touch.y, 0)
			local angle = math.atan2(to.x - from.x, from.y - to.y)
			rotation_hero = vmath.quat_rotation_z(angle)
			go.set_rotation(rotation_hero)
		elseif self.touch == "touch" then --if smart touch
			go.set_rotation(rotation_hero)
		end

		--move in direction of rotation
		if self.move == 1 and rotation_hero ~= vmath.quat(0, 0, 0, 1) then
			local distance = self.speed * self.move * dt
			local direction = vmath.rotate(rotation_hero, vmath.vector3(0, distance, 0))
			pos = pos + direction
			go.set_position(pos)
		end
		self.touch = nil

		--magic with camera
		go.set_position(pos + vmath.vector3(-550, -350, 0), "camera")
	end
end 

function on_input(self, action_id, action)
	--move to click mouse
	if not action.touch then
		if action_id == TOUCH then
			self.move = action.released and 0 or 1
			self.speed = max_speed
		end

		if not action_id then
			self.touch = action
		end
	end
end

function on_message(self, message_id, message, sender)
	if message_id == CONTACT_POINT_RESPONSE and message.other_group ~= EXP then
		--pushback
		if message.other_group == ENEMY then
			local push_to = go.get_position() + message.normal * 30
			-- knockback animation, then continue moving
			go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, push_to, go.EASING_OUTQUAD, 0.3, 0)
		end

		--contact wall
		local new_pos = go.get_position() + message.normal * message.distance
		go.set_position(new_pos)
	end
	
	--enemy damage hero
	if message_id == GET_DAMAGE then
		--get damage
		take_damage(self, message.damage)
	end
	
	--shoot
	if message_id == SHOOT then
		--send rotat and pos bullet
		local rotation = go.get_rotation()
		local position = go.get_position() + vmath.rotate(rotation, vmath.vector3(5, -10, 0))
		local to = position + vmath.rotate(rotation, vmath.vector3(0, 1000, 0))
		
		local props = { rot = rotation, pos = position, to_b = to, damage = go.get("/hero/bullet_go#bullet", "damage") }
		
		msg.post("/hero/bullet_go#bullet", "shoot", props)
		timer.delay(self.fire_speed, false, function() msg.post(".", "shoot") end)
	end
	
	--level progress
	if message_id == LVL_UPDATE then
		lvl_progress = lvl_progress + message.point

		--lvl up!
		if max_lvl_progress <= lvl_progress then
			lvl_progress = lvl_progress - max_lvl_progress
			
			self.lvl = self.lvl + 1
			
			msg.post("main:/GUI#lvl", "lvl_up", { lvl = self.lvl })

			local charact = { lvl = self.lvl, hp = self.max_HP, speed = max_speed, damage = self.damage }
			msg.post("main:/GUI#talent", "lvl_up", { characts = charact })
		end
		
		msg.post("main:/GUI#lvl", "lvl_update", { level_progress = lvl_progress })
	end

	--get new charact
	if message_id == GET_NEW_CHARACT then
		--set new charact
		self.hp = message.new_characts.new_hp
		self.speed = message.new_characts.new_speed
		self.damage = message.new_characts.new_damage

		--set new max
		self.max_HP = self.hp
		max_speed = self.speed

		--for GUI
		msg.post("main:/GUI#helth", "life_max_update", { max_life = self.max_HP, life = self.hp })

		--for bullet
		go.set("/hero/bullet_go#bullet", "damage", self.damage)
	end
			
	--if movement with slider - set rotation
	if message_id == SLIDER then
		self.move = message.move and 1 or 0
		rotation_hero = message.rot

		self.touch = "touch"
	end

	--if hero was rebel
	if message_id == REBEL then
		self.hp = self.max_HP
		msg.post("main:/GUI#helth", "life_max_update", { max_life = self.max_HP, life = self.hp })
	end
end