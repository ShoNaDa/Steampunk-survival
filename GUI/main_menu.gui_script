local RELOAD_GAME = hash("reload_game")
local FINAL_GAME = hash("final_game")
local UPDATE_STAT = hash("update_stat")
local STAT_FIRST = { enemies_killed = 0, locations_passed = 0, sec = 0, min = 0, hour = 0 }

local main_proxy = "/proxy#collectionproxy"
local game_proxy = "main:/proxy#game_proxy"
local window_enabled = "menu"
local all_nodes = {}
local all_nodes_stat = {}
local is_menu = true

--for stats
local function load_stats()
	local filename = sys.get_save_file("Steampunk survival", "statistics")
	local data_stats = sys.load(filename)
	return data_stats or STAT_FIRST
end

local function save_stats(self, statistics)
	local filename = sys.get_save_file("Steampunk survival", "statistics")
	sys.save(filename, 
	{ enemies_killed = statistics.enemies_killed, locations_passed = statistics.locations_passed, 
	sec = statistics.sec, min = statistics.min, hour = statistics.hour })
end

local function start()
	--start game
	msg.post(main_proxy, "acquire_input_focus")
	msg.post(main_proxy, "load")
	msg.post(main_proxy, "init")
	msg.post(main_proxy, "enable")
end

local function final()
	--final game
	msg.post(main_proxy, "disable")
	msg.post(main_proxy, "final")
	msg.post(main_proxy, "unload")

	msg.post(game_proxy, "disable")
	msg.post(game_proxy, "final")
	msg.post(game_proxy, "unload")
end

local function set_color(self, pick_node)
	--new color on picked node
	local old_color = gui.get_color(pick_node)
	gui.set_color(pick_node, vmath.vector4(0.5, 0.5, 0.5, 1))
	
	timer.delay(1, false,  function()
		--disable all
		for _,node in ipairs(all_nodes) do
			gui.set_enabled(node, false)
		end
		
		--old color
		gui.set_color(pick_node, old_color)
	end)
end

local function back(table_disable, table_enable)
	for _,node in ipairs(table_disable) do
		gui.set_enabled(node, false)
	end

	for _,node in ipairs(table_enable) do
		gui.set_enabled(node, true)
	end
end

function init(self)
	msg.post(".", "acquire_input_focus")
	
	--menu
	table.insert(all_nodes, gui.get_node("start"))
	table.insert(all_nodes, gui.get_node("statistic"))
	table.insert(all_nodes, gui.get_node("heroes"))
	table.insert(all_nodes, gui.get_node("settings"))
	table.insert(all_nodes, gui.get_node("exit"))
	table.insert(all_nodes, gui.get_node("back"))
	table.insert(all_nodes, gui.get_node("title"))

	--stat
	table.insert(all_nodes_stat, gui.get_node("stats/title"))
	table.insert(all_nodes_stat, gui.get_node("stats/statistic_back"))
	table.insert(all_nodes_stat, gui.get_node("stats/back"))
	table.insert(all_nodes_stat, gui.get_node("back"))

	self.statistics = { enemies_killed = 0, locations_passed = 0, sec = 0, min = 0, hour = 0 }
	self.statistics = load_stats()
end

function on_message(self, message_id, message, sender)
	--for restart
	if message_id == RELOAD_GAME then
		final()

		timer.delay(1, false,  function()
			start()
		end)
	end

	--for game over
	if message_id == FINAL_GAME then
		final()

		timer.delay(1, false,  function()
			--enable all
			for _,node in ipairs(all_nodes) do
				gui.set_enabled(node, true)
			end

			window_enabled = "menu"
		end)
	end

	--for statistics
	if message_id == UPDATE_STAT then
		if self.statistics.enemies_killed ~= nil then
			self.statistics.enemies_killed = self.statistics.enemies_killed + message.enemies_killed
			self.statistics.locations_passed = self.statistics.locations_passed + message.locations_passed
			
			self.statistics.sec = self.statistics.sec + message.sec
			--for sec < 60
			if self.statistics.sec > 59 then
				while self.statistics.sec > 59 do
					self.statistics.sec = self.statistics.sec - 60
					self.statistics.min = self.statistics.min + 1
				end
			end

			self.statistics.min = self.statistics.min + message.min
			--for min < 60
			if self.statistics.min > 59 then
				while self.statistics.min > 59 do
					self.statistics.min = self.statistics.min - 60
					self.statistics.hour = self.statistics.hour + 1
				end
			end
			
			self.statistics.hour = self.statistics.hour + message.hour
		else
			self.statistics = message
		end
		
		save_stats(self, self.statistics)
	end
end

function on_input(self, action_id, action)
	if action.released then
		if window_enabled == "menu" then
			--click start
			if gui.pick_node(all_nodes[1], action.x, action.y) then
				window_enabled = "start"
				set_color(self, all_nodes[1])

				timer.delay(1, false,  start)
			end

			--click statistic
			if gui.pick_node(all_nodes[2], action.x, action.y) then
				window_enabled = "stats"
				set_color(self, all_nodes[2])

				timer.delay(1, false,  function()
					--enable all stat
					for _,node in ipairs(all_nodes_stat) do
						gui.set_enabled(node, true)
					end
				end)

				self.statistics = load_stats()
				if self.statistics.enemies_killed ~= nil then
					gui.set_text(gui.get_node("stats/enemy_killed_text"), 
					"Enemy killed: " .. self.statistics.enemies_killed)
					gui.set_text(gui.get_node("stats/locations_passed_text"), 
					"Locations passed: " .. self.statistics.locations_passed)

					self.life_time = self.statistics.hour .. ":" .. self.statistics.min .. ":" .. self.statistics.sec
					gui.set_text(gui.get_node("stats/life_time_text"), 
					"Life time: " .. self.life_time)
				end
			end

			--click heroes
			if gui.pick_node(all_nodes[3], action.x, action.y) then
				window_enabled = "heroes"
				set_color(self, all_nodes[3])
			end

			--click settings
			if gui.pick_node(all_nodes[4], action.x, action.y) then
				window_enabled = "settings"
				set_color(self, all_nodes[4])
			end
			
			--click exit
			if gui.pick_node(all_nodes[5], action.x, action.y) then
				set_color(self, all_nodes[5])

				timer.delay(1, false,  function()
					sys.exit(0)
				end)
			end
		elseif window_enabled == "stats" then
			--click back stat
			if gui.pick_node(all_nodes_stat[3], action.x, action.y) then
				set_color(self, all_nodes_stat[3])

				timer.delay(1, false,  function()
					back(all_nodes_stat, all_nodes)

					window_enabled = "menu"
				end)
			end
		end
	end
end